Vert.x:
.......

What is Vertx?

Eclipse Vert.x is a tool-kit for building reactive applications on the JVM.

Vertx is functional,event driven,object oriented,reactive,non blocking io and async tookit for building "distributed application - Micro service" on java virtual machine.

Vert.x is Polyglot tool kit for building micro services application.

Verx allows different programming languages can talk each other.

Polyglot means multi technology /language.

 Vertx supports Polyglot on jvm.

Does JVM support multi language(Polyglot)?

   Yes!.

2002,JCP published  specfication called "multi language" on jvm.
 
Groovy, was the first reference implementation of that spec 
Kotlin
Jython - python + java

Vetx PolyGlot

You can use Vert.x with multiple languages including Java, Kotlin, JavaScript, Groovy, Ruby and Scala.

Vert.x doesn't preach about what language is best — you choose the languages you want based on the task at hand and the skill-set of your team.

We provide idiomatic APIs for every language that Vert.x supports.

 How these languages works on jvm/
   jvm contract is only "byte code"

             groovy,kotlin,javascript,scala,ruby.......
	                |
                   compilers
                        |
                      .class
                        |
                       jvm
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

non blocking io and async :
...........................

IO:

Hardware devices typically provide the ability to input data into the computer or output data from the computer.

To simplify the ability to support a variety of hardware devices, standardized application programming interfaces (API) are used.

Application programs use the "System Call API" to request one of a finite set of preset I/O requests from the Operating System.

The Operating System uses algorithms for processing the request that are device independent.


The Operating System uses another API to request data from the device driver.

The device driver is third party software that knows how to interact with the specific device to perform the I/O.

Sometimes we have a layering of device drivers where one device driver will call on another device driver to facilitate the I/O.

 An example of this is when devices are connected to a USB port. The driver for the device will make use of the USB device driver to facilitate passing data to and from the device.


IO SYSTEM CALL Api:

Java - io api
 |
jvm
jni -  io api - java native interface api , which low level api to os
|
os
|
system calls - os io api
|
device driver - io api
|
----------device

Socket :

 It is entry and exit point of device io world.
Socket isloates  kernal space and device drivers

File Descriptor:
 File Descriptor is low level representation of io.


flow of io operation:

user-----application----call read sys call ----socket----fd--wait for io


Every application and programming languages by default have blocking apis.

read call in os is blocking call.

java io api

 InputStream
  ------read--------------------->os read io----->fd.



Non Blocking:
.............

IO Multiplixing:
................

Watching fds peridicall for io .
Event loop /while loop is watcher keeps on watching file descripters.

How to monitor many file descriptors by one single event loop?


Event loop algorthims:

Polling / watching fds:

epoll  - linux
kqueue, kevent -- kernel event notification mechanism : FreeBsd versions; mac, unix.......
I/O Completion Ports  - Windows


Java and Non blocking Programming:

Blocking io api  in low is read
Non blockign io api in low level is select

java high level api io streams
 InputStream.read --------------------read method


No!

Yes from Java 7 called "Dolphin".

Dolphin introduced experimental model for building fast disk io, called "NIO"
NONBlocking IO.


Blocking io code: network code:
................................

import java.io.*;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;

public class SynchronousEcho {

  public static void main(String[] args) throws Throwable {
    ServerSocket server = new ServerSocket();
    server.bind(new InetSocketAddress(3000));
    while (true) {   // <1>
      Socket socket = server.accept();
      new Thread(clientHandler(socket)).start();
    }
  }

  private static Runnable clientHandler(Socket socket) {
    return () -> {
      try (
        BufferedReader reader = new BufferedReader(
          new InputStreamReader(socket.getInputStream()));
        PrintWriter writer = new PrintWriter(
          new OutputStreamWriter(socket.getOutputStream()))) {
        String line = "";
        while (!"/quit".equals(line)) {
          line = reader.readLine();      // <2>
          System.out.println("~ " + line);
          writer.write(line + "\n");  // <3>
          writer.flush();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
    };
  }
}

NIO version: non blocking version

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.Iterator;
import java.util.regex.Pattern;

public class AsynchronousEcho {

  public static void main(String[] args) throws IOException {
    Selector selector = Selector.open();

    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    serverSocketChannel.bind(new InetSocketAddress(3000));
    serverSocketChannel.configureBlocking(false);
    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

    while (true) {
      selector.select();
      Iterator<SelectionKey> it = selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key = it.next();
        if (key.isAcceptable()) {
          newConnection(selector, key);
        } else if (key.isReadable()) {
          echo(key);
        } else if (key.isWritable()) {
          continueEcho(selector, key);
        }
        it.remove();
      }
    }
  }

  private static class Context {
    private final ByteBuffer nioBuffer = ByteBuffer.allocate(512);
    private String currentLine = "";
    private boolean terminating = false;
  }

  private static final HashMap<SocketChannel, Context> contexts = new HashMap<>();

  private static void newConnection(Selector selector, SelectionKey key) throws IOException {
    ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
    SocketChannel socketChannel = serverSocketChannel.accept();
    socketChannel
      .configureBlocking(false)
      .register(selector, SelectionKey.OP_READ);
    contexts.put(socketChannel, new Context());
  }

  private static final Pattern QUIT = Pattern.compile("(\\r)?(\\n)?/quit$");

  private static void echo(SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      socketChannel.read(context.nioBuffer);
      context.nioBuffer.flip();
      context.currentLine = context.currentLine + Charset.defaultCharset().decode(context.nioBuffer);
      if (QUIT.matcher(context.currentLine).find()) {
        context.terminating = true;
      } else if (context.currentLine.length() > 16) {
        context.currentLine = context.currentLine.substring(8);
      }
      context.nioBuffer.flip();
      int count = socketChannel.write(context.nioBuffer);
      if (count < context.nioBuffer.limit()) {
        key.cancel();
        socketChannel.register(key.selector(), SelectionKey.OP_WRITE);
      } else {
        context.nioBuffer.clear();
        if (context.terminating) {
          cleanup(socketChannel);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }

  private static void cleanup(SocketChannel socketChannel) throws IOException {
    socketChannel.close();
    contexts.remove(socketChannel);
  }

  private static void continueEcho(Selector selector, SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      int remainingBytes = context.nioBuffer.limit() - context.nioBuffer.position();
      int count = socketChannel.write(context.nioBuffer);
      if (count == remainingBytes) {
        context.nioBuffer.clear();
        key.cancel();
        if (context.terminating) {
          cleanup(socketChannel);
        } else {
          socketChannel.register(selector, SelectionKey.OP_READ);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }
}


Problmes with NIO :

It is also important to note that like most JDK APIs, java.nio focuses solely on what it does (here, I/O APIs).
 It does not provide higher-level protocol-specific helpers, like for writing HTTP clients and servers.
 
Also, java.nio does not prescribe a threading model, which is still important to properly utilize CPU 
cores, handle asynchronous I/O events, and articulate the application processing logic.

This is why, in practice, developers rarely deal with Java NIO. 

Networking libraries like Netty and Apache Mina solve the shortcomings of Java NIO


NETTY

 "Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. "

It greatly simplifies and streamlines network programming such as TCP and UDP socket server.

Unified API for various transport types - blocking and non-blocking socket

Based on a flexible and extensible event model which allows clear separation of concerns- The first Reactor Model on jvm.

        		 Netty Application
		             |
          	         nettycore
			     |
			    nio
			     |
		            jvm

Apache MINA 

  Apache MINA is a network application framework which helps users develop high performance and high scalability network applications easily.
 It provides an abstract event-driven asynchronous API over various transports such as TCP/IP and 

UDP/IP via Java NIO.
NIO framework library,
client server framework library, or
a networking socket library

		    Apache MINA 
		         |
          	      Minaapi
			 |
			nio
			 |
		        jvm

Eclipse Vert.x is one of them.


Vertx:

Birth of Vertx Project

Vertx was born to simulate Node.js Capability on JVM.
 initally it was named "Node.X"

A core project, called vertx-core, provides the APIs for asynchronous programming, non-blocking I/O, streaming, and convenient access to networked protocols such as TCP, UDP, DNS, HTTP or Web Sockets,

Vertx is industry ready , polyglot toolkit for building Non blocking,async,evented io applications.

Vertx has been built on the top of Netty Core.

Vertx is industry ready , polyglot toolkit for building Non blocking,async,evented io applications.

Vertx has been built on the top of Netty Core.


			VertxApplication
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM

Objective of VertX:
   
    100% non blocking applications on jvm.



NonBlocking IO Apis


                     NonBlocking IO Application -VertApplication
   --------------------------------------------------------------------		
    Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM


vert-x is poly glot:

 Vertx is java technology platform, Vertx runs on JVM.
 Fundamentally JVM supports multiple language as JVM Spec dt 2003.


             Java PL  Groovy Kotlin  Javascript  scala Ruby
	            	|       |     |         |         |     |
      -------------------------------------------------------------
                               .class
				                         |
   --------------------------------------------------------------------		
       Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM
                                


				 Vertx Tech Stack


Spring is collection of projects called modules
  like core,data,mvc,integration,micro service.............

Like Spring Vertx is also collection projects

Vertx-core
vertx-web
Vertx-Data
Vertx-Reactive Extension
Vertx-Microservices
Vertx-Messaging
Vertx-Security
Vertx-Integration
Vertx-Devops Engineering
Vertx-Testing
Vertx-Clusters
Vertx-Services
Vertx-Cloud

Vertx-Core:
Writing TCP clients and servers
Writing HTTP clients and servers including support for WebSockets
The Event bus
Shared data - local maps and clustered distributed maps
Periodic and delayed actions
Deploying and undeploying Verticles
Datagram Sockets
DNS client
File system access
High availability
Native transports
Clustering   

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Lets code:

-Vertx Project setup

-Maven Project
-Gradle Project

1.plain maven project, add vertx depedencies,You can use template entry method provided by vertx .

2.Vertx Starter project

3.Vertx maven cli project

Vetx Distribution:

-maven
-zip

download zip and extract and set path 
C:\softwares\vert.x-3.9.2-full\vertx\bin

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
How to run vertx application?

We have many ways:

1.via maven.

running:
To launch your tests:

./mvnw clean test
To package your application:

./mvnw clean package
To run your application:

./mvnw clean compile exec:java



2.fat jar running:

you can pack vertx application into fat jar and you can

mvnw clean package

Running

java -jar target/vertx-apps-1.0.0-SNAPSHOT-fat.jar


3.via vertx command line.


vertx run ProgrammName.java

C:\session\ibm\Sep\vertx-apps\src\main\java\com\ibm\vertx>vertx run MainVerticle.java
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
HTTP server started on port 8888
Succeeded in deploying verticle


4.via coding - to be discussed later

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Vertx Core Concepts:

1.Vertx Instance
2.Verticle

io.vertx.core package is core package

Vertx Instance:

 It is Object,Container Object. like Spring Container.

-it is entry and exit point of vertx application.
-on jvm(single) process can have single vertx instance.
-vertx can host other objects.


To create an instance of this class you can use the static factory methods:

 vertx(), 
 vertx(io.vertx.core.VertxOptions) 
 clusteredVertx(io.vertx.core.VertxOptions, Handler).

1.how to create vertx instance

Vertx Instance can do 

Creating TCP clients and servers
Creating HTTP clients and servers
Creating DNS clients
Creating Datagram sockets
Setting and cancelling periodic and one-shot timers
Getting a reference to the event bus API
Getting a reference to the file system API
Getting a reference to the shared data API
Deploying and undeploying verticles


How to create vertx instance?

package com.ibm.vertx.core;

import io.vertx.core.Vertx;

public class CreateVertxInstanceUsingFactory {
  public static void main(String[] args) {
    //create Vertx Container object
    Vertx vertx = Vertx.vertx();
    System.out.println(vertx.toString());
  }
}

Verticle:
  -It is java object
  -It can be deployed and undeployed on vertx instance.
  -It is based on design pattern called "Actor-like Model"
  -Verticles are bound to "Event loop" , are processed by event loops.

erticle is interface which provides life cycle methods 
  -init
  -start - called when verticle during deployment
  -stop  - called when verticles during undeployment

 How to use Verticle?

 AbstractVerticle is base class for creating our own verticles.

eg:
 if you are going to implement servlet , 

public class MyServlet extends HttpServlet{

  init  
  doGet
  doPost
  destroy
}

Use case First verticle :



import io.vertx.core.AbstractVerticle;

public class HelloWorldVerticle extends AbstractVerticle {

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("HelloWorld Verticle is deployed");
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("HelloWorld Verticle is un deployed");

  }
}

if you run any verticle, we need launcher

lanucher could be main method or vertx cmd , via maven - maven needs lanucher

in case maven /fat , in side pom.xml we have to define, launcer

  <properties>
    <main.verticle>com.ibm.vertx.MainVerticle</main.verticle>
  </properties>

 <Main-Class>io.vertx.core.Launcher</Main-Class>
 <Main-Verticle>${main.verticle}</Main-Verticle>


Programmetic deployment:
.......................
package com.ibm.vertx.core;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Vertx;

public class HelloWorldVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    //vertx.deployVerticle(new HelloWorldVerticle());
    //pass class name in string format
    //vertx.deployVerticle("com.ibm.vertx.core.HelloWorldVerticle");
    vertx.deployVerticle(HelloWorldVerticle.class.getName());
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("HelloWorld Verticle is deployed");
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("HelloWorld Verticle is un deployed");
  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////

via Runner class deployement:
..............................

  public static void main(String[] args) {
    Runner.runExample(HelloWorldVerticle.class);
  }



Vertx apps:
 Collection of Verticles which can talk each other, they can exchanges messages

Vertx Application must have one single root / main verticle from where verticle application is started.



package com.ibm.vertx.verticles;

import com.ibm.vertx.core.HelloWorldVerticle;
import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;

class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Greeter ");
  }
}

class HelloVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Hello");
  }
}

public class MainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(MainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    //access vertx instance via abstract verticle
    System.out.println("Main Verticle starts");
    vertx.deployVerticle(new GreeterVerticle());
    vertx.deployVerticle(new HelloWorldVerticle());
  }
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Vert x and Event loop:

Vertx process events comming from kernal space , via event loop, still it is while loop but that loop
bound to a thread , that thread is called event loop thread.

Every verticle by default is bound to a thread Event loop thread.

Verticle can handle events and process them.

How many event loops are there in vertx?

In node js , only one event loop.

In vertx per cpu core 2 event loops.

eg , if i have 12 cores - 24 event loop.


Event Handlers:
..............

Vertx Handlers - Event Handlers:
................................

Vertx Event Handlers can be in written in two ways

1.Future && Promise Pattern : Functional style
2.Reactive Pattern - RxJava2


if you come from java script && node.js background,you know the concept called "Callback function" - callback function is other wise called as "listener function" or "handler function".



1.Handler functions are not called by developers directly like other functions.
2.Handlers functions are called by a thread "Event Loop".
3.Handler functions are available inside Event Queue as passive instruction.
4.Once async operation(task-database connnection) is completed, os triggers event, along with event, data, and its   handler is pushed into event queue, event loop starts processing.

What is handler function/callback function/listener function for?
To handle async success /failure result.
   The result of async opertion could be either success or failure


io.vertx.Future:

-it is interface used to handle async success/failure results.

io.vertx.core

Future Interface 
				AsyncResult       Handler
				-------------------------
					   |
				     Future



Future interface is used to handle the result of async operation.


Future is interface , encapsulate response(Success/failure), we need to create Object 
for "Future" implementation
 Future f = Future.future() // create FutureImpl object

Two major api for response:


1.complete()  and complete(T result) =>Success Response, encasulated inside this api

2.fail(String failureMessage) and fail(Throwable cause) =>Failure response, encapsulate  inside this api.


Handler apis for handling response;
...................................

1.succeeded() : empty response
2.default Future<T> setHandler(Handler<AsyncResult<T>> handler)
3.default Future<T> onComplete(Handler<AsyncResult<T>> handler)
4.onSuccess
5.onFailure

AsyncResult interface apis

 -result() - get the success result sent by Future
 -cause()   -get the failure result sent by Future
 -succeed() -test whether it was success or failure
 -failed()  -test whether it was failure or success


coding use case
Future may
 -not return any value ; empty
 -may return success result
 -may return failure result
 -may return either success/failure - biz use case

steps

callee:
1.create future object using Future.future factory method
2.wrap result -  empty / success/failure
3.return the future.

caller
4.handle the future


package com.ibm.vertx.asyncwrappers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.example.util.Runner;


class FutureVerticle extends AbstractVerticle {

  //future object creation and how to use
  public Future<Void> getEmptyFuture() {
    //how to send empty success response
    Future<Void> future = Future.future();
    //encapsulate response : success/ failure
    future.complete();
    //return future instance reference
    return future;
  }

  //future object which sends success result ; String
  public Future<String> getSuccessFuture() {
    //create Future
    Future<String> future = Future.future();

    //encapsulate success result
    future.complete("Hello , This is Vertx future");

    return future;
  }

  //future object which sends failure result ; String
  public Future<String> getFailureFuture() {
    //create Future
    Future<String> future = Future.future();

    //encapsulate success result
    future.fail("Hello ,This failed Response");

    return future;
  }

  //biz logic
  public Future<String> loginFuture() {
    //create Future
    Future<String> future = Future.future();
    //biz logic
    String userName = "admin";
    String password = "admin";
    if (userName.equals("admin") && password.equals("admin")) {
      future.complete("Login Success " + userName);
    } else {
      future.fail("Login failed");
    }

    return future;
  }


  @Override
  public void start() throws Exception {
    super.start();
    //handle async result.
    if (getEmptyFuture().succeeded()) {
      System.out.println("Result is success");
    }
    //handle success response
    getSuccessFuture().setHandler(new Handler<AsyncResult<String>>() {
      @Override
      public void handle(AsyncResult<String> event) {
        //read result
        if (event.succeeded()) {
          System.out.println(event.result());
        } else {
          System.out.println(event.cause());
        }
      }
    });
    getSuccessFuture().setHandler(event -> {
      //read result
      if (event.succeeded()) {
        System.out.println(event.result());
      } else {
        System.out.println(event.cause());
      }
    });
    getSuccessFuture().onComplete(event -> {
      //read result
      if (event.succeeded()) {
        System.out.println(event.result());
      } else {
        System.out.println(event.cause());
      }
    });
    getSuccessFuture().onSuccess(response -> System.out.println(response));
    getSuccessFuture().onSuccess(System.out::println);
    //
    getFailureFuture().onComplete(event -> {
      //read result
      if (event.succeeded()) {
        System.out.println(event.result());
      } else {
        System.out.println(event.cause());
      }
    });
    getFailureFuture().onFailure(System.out::println);
    ////////////////////////////////////////////////////////////
    loginFuture().onComplete(event -> {
      if (event.succeeded()) {
        System.out.println(event.result());
      } else {
        System.out.println(event.cause());
      }
    });
    loginFuture()
      .onSuccess(System.out::println)
      .onFailure(System.out::println);

  }
}


public class FutureMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(FutureMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new FutureVerticle());
  }
}
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Future Object creation:

1.Future future = Future.future()

2.Future.succeedFuture
  Future.FailedFuture

 public Future<String> loginFutureUsingFactory() {
    //biz logic
    String userName = "admin";
    String password = "admin";
    if (userName.equals("admin") && password.equals("admin")) {
      return Future.succeededFuture("Login Success " + userName);
    }
    return Future.failedFuture("Login failed");

  }

Async Wrapper Object : Promise:
...............................

Promise is async abstraction largly promoted by javascript community.

Dont Compare  javascript Promises with Vertx Promises , because both are different.

Promise is "semantically meaningfull abstraction" for handling asyn results.

Many times developers confuse with java Future and Vertx Future.

Promises can't be processed directly with onComplete/setHandler/OnSuccecc/onFailure apis.



package com.ibm.vertx.asyncwrappers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class PromiseVerticle extends AbstractVerticle {

  public Future<String> getSuccess() {
    Promise<String> promise = Promise.promise();
    promise.complete("Hello Promise");
    return promise.future();
  }

  public Future<String> login() {
    //create Future
    Promise<String> promise = Promise.promise();
    //biz logic
    String userName = "admin";
    String password = "admin";
    if (userName.equals("admin") && password.equals("admin")) {
      promise.complete("Login Success " + userName);
    } else {
      promise.fail("Login failed");
    }

    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    getSuccess().onSuccess(System.out::println);
    login()
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}

public class PromiseVerticleMain extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(PromiseVerticleMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new PromiseVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Legacy Application flow : object oriented and sync flow
  
dependent operations  , should happen one by one

Object oriented seq work flow

 1.connect db - connect()
 2.Query results -queryResult()
 3.Formate results -formateResult()
 4.add results into http response stream - write()
 5.send/flush the results to clients - send()

 Connection con=connect();
 QueryResult queryres=con.queryResult()
 ..................................................................

 Functional sequential workflow:

 Nested Callback : Callback chaining: functional style

  Handler function is called as callback function

"The out put of one callback is input to the another callback : nested callbacks

   cb1
     --cb2
         -cb3
            --cbN
              --process the result.


Use case :

 getUser ----|if data is available
			|	|
			|
			      	 call login method with  output of getUser
                        |
		     if not
			 -error


package com.ibm.vertx.callback.composition;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class UserVerticle extends AbstractVerticle {

  public Future<String> getUser() {
    Promise<String> promise = Promise.promise();
    //biz
    String userName = "admin";
    if (userName != null) {
      promise.complete(userName);
    } else {
      promise.fail("User not found");
    }

    return promise.future();
  }

  public Future<String> login(String userName) {
    Promise<String> promise = Promise.promise();
    //biz
    if (userName.equals("admin")) {
      promise.complete("login success");
    } else {
      promise.fail("login failed");
    }
    return promise.future();
  }

  public Future<String> page(String status) {
    Promise<String> promise = Promise.promise();
    //biz
    if (status.equals("login success")) {
      promise.complete("Admin Page");
    } else {
      promise.fail("Guest Page");
    }
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    getUser().onComplete(event -> {
      if (event.succeeded()) {
        System.out.println("getUser is called ");
        login(event.result()).onComplete(loginevent -> {
          if (loginevent.succeeded()) {
            System.out.println("login is called");
            page(loginevent.result()).onComplete(pageevent -> {
              System.out.println("Page is called");
              if (pageevent.succeeded()) {
                System.out.println(pageevent.result());
              } else {
                System.out.println(pageevent.cause());
              }
            });
          } else {
            System.out.println(loginevent.cause());
          }
        });
      } else {
        System.out.println(event.cause());
      }
    });
  }
}


public class FunctionalCompositionVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(FunctionalCompositionVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new UserVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
callback Hell:
 The way we write nested callbacks.
 doom of pyrmid


getUser().onComplete(event -> {
      if (event.succeeded()) {
        System.out.println("getUser is called ");
        login(event.result()).onComplete(loginevent -> {
          if (loginevent.succeeded()) {
            System.out.println("login is called");
            page(loginevent.result()).onComplete(pageevent -> {
              System.out.println("Page is called");
              if (pageevent.succeeded()) {
                System.out.println(pageevent.result());
              } else {
                System.out.println(pageevent.cause());
              }
            });
          } else {
            System.out.println(loginevent.cause());
          }
        });
      } else {
        System.out.println(event.cause());
      }
    });



Look at the above code , ask your self

1.is it easy to understand?
2.is it easy to scale
3.is it easy to maintain

No!



can we escape from callback hell problem, how to write better callback based programming?

Yes! 


Solution to callback Hell:
..........................
compose method of Future


package com.ibm.vertx.callback.composition;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class UserVerticle extends AbstractVerticle {

  public Future<String> getUser() {
    Promise<String> promise = Promise.promise();
    //biz
    String userName = "admin";
    if (userName != null) {
      promise.complete(userName);
    } else {
      promise.fail("User not found");
    }

    return promise.future();
  }

  public Future<String> login(String userName) {
    Promise<String> promise = Promise.promise();
    //biz
    if (userName.equals("admin")) {
      promise.complete("login success");
    } else {
      promise.fail("login failed");
    }
    return promise.future();
  }

  public Future<String> page(String status) {
    Promise<String> promise = Promise.promise();
    //biz
    if (status.equals("login success")) {
      promise.complete("Admin Page");
    } else {
      promise.fail("Guest Page");
    }
    return promise.future();
  }

  public void callbackHellCode() {
    getUser().onComplete(event -> {
      if (event.succeeded()) {
        System.out.println("getUser is called ");
        login(event.result()).onComplete(loginevent -> {
          if (loginevent.succeeded()) {
            System.out.println("login is called");
            page(loginevent.result()).onComplete(pageevent -> {
              System.out.println("Page is called");
              if (pageevent.succeeded()) {
                System.out.println(pageevent.result());
              } else {
                System.out.println(pageevent.cause());
              }
            });
          } else {
            System.out.println(loginevent.cause());
          }
        });
      } else {
        System.out.println(event.cause());
      }
    });
  }
  //how to avoid callback hell code

  public void compose() {

    getUser().compose(userName -> {
      System.out.println("getUser is called ");
      return login(userName);
    }).compose(status -> {
      System.out.println("login is called");
      return page(status);
    }).onSuccess(System.out::println)
      .onFailure(System.out::println);

    getUser()
      .compose(userName -> login(userName))
      .compose(status -> page(status))
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }

  @Override
  public void start() throws Exception {
    super.start();
    compose();
  }
}


public class FunctionalCompositionVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(FunctionalCompositionVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new UserVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Function as Parameter pattern; 


  //we dont want to return future/promise but we need to transfer data to caller

  public void prepareDatabase(Handler<AsyncResult<String>> aHandler) {
    String connectionString = "localhost;3302;mongodb";
    if (connectionString != null) {
      //wrap result into future
      aHandler.handle(Future.succeededFuture(connectionString));
    } else {
      aHandler.handle(Future.failedFuture("Connection is not available"));
    }
  }

   prepareDatabase(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause());
      }
    });

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Data Formates in vertx:

1.Buffer
2.JSON object
3.Message


Buffer
JSON


Buffer:

1.Verticles running in vertx often need to process blocks of data.
2.For instance , data from an incomming http request, data loaded from the disk or data generated as response to http request etc.
3.A Buffer in vertx can hold binary data.
4.Buffer is similar to byte array, except the buffer can expand its capacity dynamically  as you write data to it.

package com.ibm.vertx.dataformat;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.buffer.Buffer;
import io.vertx.example.util.Runner;

public class BufferVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BufferVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    //Buffer
    Buffer buffer = Buffer.buffer();
    buffer.appendString("Hello");
    buffer.appendString("Hai");
    buffer.appendString("Welcome");
    buffer.appendString("How are you");
    buffer.appendString("this is binary data");
    System.out.println(buffer.length());
    System.out.println(buffer.toString());
  }
}

JSON Object :Data Interchange format 

Vertx provides a Json Objects

1.JsonObject
2.JsonArray

package com.ibm.vertx.dataformat;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

public class JSONVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(JSONVerticle.class);
  }

  public void simpleJSON() {
    JsonObject message = new JsonObject();
    message.put("name", "Subramanian");
    message.put("when", 1);
    message.put("status", true);
    System.out.println(message.getString("name"));
    System.out.println(message.getInteger("when"));
    System.out.println(message.getBoolean("status"));
    //json.stringify - string representation
    System.out.println(message.encodePrettily());

  }

  //vertx apis are fluent API:A fluent API is where multiple methods calls can be chained together
  public void simpleWithFluentJSON() {
    JsonObject message = new JsonObject().put("name", "Subramanian").put("when", 1).put("status", true);
    System.out.println(message.getString("name"));
    System.out.println(message.getInteger("when"));
    System.out.println(message.getBoolean("status"));
    //json.stringify - string representation
    System.out.println(message.encodePrettily());
  }

  //nested json
  public void nestedJson() {
    JsonObject message = new JsonObject().put("name", "Subramanian")
      .put("when", 1)
      .put("status", true)
      .put("address", new JsonObject().put("city", "coimbatore")
        .put("state", "Tamil Nadue"));
    System.out.println(message.getString("name"));
    System.out.println(message.getInteger("when"));
    System.out.println(message.getBoolean("status"));
    //json.stringify - string representation
    System.out.println(message.encodePrettily());
  }

  //list of jsons [ ]
  public void listofJson() {
    JsonArray list = new JsonArray()
      .add(new JsonObject().put("name", "Subramanian")
        .put("when", 1)
        .put("status", true)
        .put("address", new JsonObject().put("city", "coimbatore")
          .put("state", "Tamil Nadue")))
      .add(new JsonObject().put("name", "Subramanian")
        .put("when", 1)
        .put("status", true)
        .put("address", new JsonObject().put("city", "coimbatore")
          .put("state", "Tamil Nadue")));

    //json.stringify - string representation
    System.out.println(list.encodePrettily());
  }

  //how to reuturn json with Future/Promise
  public Future<JsonObject> getPromise() {
    Promise<JsonObject> promise = Promise.promise();
    JsonObject message = new JsonObject().put("name", "Subramanian")
      .put("when", 1)
      .put("status", true)
      .put("address", new JsonObject().put("city", "coimbatore")
        .put("state", "Tamil Nadue"));
    promise.complete(message);
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    simpleJSON();
    simpleWithFluentJSON();
    nestedJson();
    listofJson();
    getPromise().onSuccess(res -> {
      System.out.println(res.encodePrettily());
    });
  }
}



























