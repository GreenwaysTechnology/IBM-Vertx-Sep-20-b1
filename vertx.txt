Vert.x:
.......

What is Vertx?

Eclipse Vert.x is a tool-kit for building reactive applications on the JVM.

Vertx is functional,event driven,object oriented,reactive,non blocking io and async tookit for building "distributed application - Micro service" on java virtual machine.

Vert.x is Polyglot tool kit for building micro services application.

Verx allows different programming languages can talk each other.

Polyglot means multi technology /language.

 Vertx supports Polyglot on jvm.

Does JVM support multi language(Polyglot)?

   Yes!.

2002,JCP published  specfication called "multi language" on jvm.
 
Groovy, was the first reference implementation of that spec 
Kotlin
Jython - python + java

Vetx PolyGlot

You can use Vert.x with multiple languages including Java, Kotlin, JavaScript, Groovy, Ruby and Scala.

Vert.x doesn't preach about what language is best — you choose the languages you want based on the task at hand and the skill-set of your team.

We provide idiomatic APIs for every language that Vert.x supports.

 How these languages works on jvm/
   jvm contract is only "byte code"

             groovy,kotlin,javascript,scala,ruby.......
	                |
                   compilers
                        |
                      .class
                        |
                       jvm
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

non blocking io and async :
...........................

IO:

Hardware devices typically provide the ability to input data into the computer or output data from the computer.

To simplify the ability to support a variety of hardware devices, standardized application programming interfaces (API) are used.

Application programs use the "System Call API" to request one of a finite set of preset I/O requests from the Operating System.

The Operating System uses algorithms for processing the request that are device independent.


The Operating System uses another API to request data from the device driver.

The device driver is third party software that knows how to interact with the specific device to perform the I/O.

Sometimes we have a layering of device drivers where one device driver will call on another device driver to facilitate the I/O.

 An example of this is when devices are connected to a USB port. The driver for the device will make use of the USB device driver to facilitate passing data to and from the device.


IO SYSTEM CALL Api:

Java - io api
 |
jvm
jni -  io api - java native interface api , which low level api to os
|
os
|
system calls - os io api
|
device driver - io api
|
----------device

Socket :

 It is entry and exit point of device io world.
Socket isloates  kernal space and device drivers

File Descriptor:
 File Descriptor is low level representation of io.


flow of io operation:

user-----application----call read sys call ----socket----fd--wait for io


Every application and programming languages by default have blocking apis.

read call in os is blocking call.

java io api

 InputStream
  ------read--------------------->os read io----->fd.



Non Blocking:
.............

IO Multiplixing:
................

Watching fds peridicall for io .
Event loop /while loop is watcher keeps on watching file descripters.

How to monitor many file descriptors by one single event loop?


Event loop algorthims:

Polling / watching fds:

epoll  - linux
kqueue, kevent -- kernel event notification mechanism : FreeBsd versions; mac, unix.......
I/O Completion Ports  - Windows


Java and Non blocking Programming:

Blocking io api  in low is read
Non blockign io api in low level is select

java high level api io streams
 InputStream.read --------------------read method


No!

Yes from Java 7 called "Dolphin".

Dolphin introduced experimental model for building fast disk io, called "NIO"
NONBlocking IO.


Blocking io code: network code:
................................

import java.io.*;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;

public class SynchronousEcho {

  public static void main(String[] args) throws Throwable {
    ServerSocket server = new ServerSocket();
    server.bind(new InetSocketAddress(3000));
    while (true) {   // <1>
      Socket socket = server.accept();
      new Thread(clientHandler(socket)).start();
    }
  }

  private static Runnable clientHandler(Socket socket) {
    return () -> {
      try (
        BufferedReader reader = new BufferedReader(
          new InputStreamReader(socket.getInputStream()));
        PrintWriter writer = new PrintWriter(
          new OutputStreamWriter(socket.getOutputStream()))) {
        String line = "";
        while (!"/quit".equals(line)) {
          line = reader.readLine();      // <2>
          System.out.println("~ " + line);
          writer.write(line + "\n");  // <3>
          writer.flush();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
    };
  }
}

NIO version: non blocking version

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.Iterator;
import java.util.regex.Pattern;

public class AsynchronousEcho {

  public static void main(String[] args) throws IOException {
    Selector selector = Selector.open();

    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    serverSocketChannel.bind(new InetSocketAddress(3000));
    serverSocketChannel.configureBlocking(false);
    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

    while (true) {
      selector.select();
      Iterator<SelectionKey> it = selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key = it.next();
        if (key.isAcceptable()) {
          newConnection(selector, key);
        } else if (key.isReadable()) {
          echo(key);
        } else if (key.isWritable()) {
          continueEcho(selector, key);
        }
        it.remove();
      }
    }
  }

  private static class Context {
    private final ByteBuffer nioBuffer = ByteBuffer.allocate(512);
    private String currentLine = "";
    private boolean terminating = false;
  }

  private static final HashMap<SocketChannel, Context> contexts = new HashMap<>();

  private static void newConnection(Selector selector, SelectionKey key) throws IOException {
    ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
    SocketChannel socketChannel = serverSocketChannel.accept();
    socketChannel
      .configureBlocking(false)
      .register(selector, SelectionKey.OP_READ);
    contexts.put(socketChannel, new Context());
  }

  private static final Pattern QUIT = Pattern.compile("(\\r)?(\\n)?/quit$");

  private static void echo(SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      socketChannel.read(context.nioBuffer);
      context.nioBuffer.flip();
      context.currentLine = context.currentLine + Charset.defaultCharset().decode(context.nioBuffer);
      if (QUIT.matcher(context.currentLine).find()) {
        context.terminating = true;
      } else if (context.currentLine.length() > 16) {
        context.currentLine = context.currentLine.substring(8);
      }
      context.nioBuffer.flip();
      int count = socketChannel.write(context.nioBuffer);
      if (count < context.nioBuffer.limit()) {
        key.cancel();
        socketChannel.register(key.selector(), SelectionKey.OP_WRITE);
      } else {
        context.nioBuffer.clear();
        if (context.terminating) {
          cleanup(socketChannel);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }

  private static void cleanup(SocketChannel socketChannel) throws IOException {
    socketChannel.close();
    contexts.remove(socketChannel);
  }

  private static void continueEcho(Selector selector, SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      int remainingBytes = context.nioBuffer.limit() - context.nioBuffer.position();
      int count = socketChannel.write(context.nioBuffer);
      if (count == remainingBytes) {
        context.nioBuffer.clear();
        key.cancel();
        if (context.terminating) {
          cleanup(socketChannel);
        } else {
          socketChannel.register(selector, SelectionKey.OP_READ);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }
}


Problmes with NIO :

It is also important to note that like most JDK APIs, java.nio focuses solely on what it does (here, I/O APIs).
 It does not provide higher-level protocol-specific helpers, like for writing HTTP clients and servers.
 
Also, java.nio does not prescribe a threading model, which is still important to properly utilize CPU 
cores, handle asynchronous I/O events, and articulate the application processing logic.

This is why, in practice, developers rarely deal with Java NIO. 

Networking libraries like Netty and Apache Mina solve the shortcomings of Java NIO


NETTY

 "Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. "

It greatly simplifies and streamlines network programming such as TCP and UDP socket server.

Unified API for various transport types - blocking and non-blocking socket

Based on a flexible and extensible event model which allows clear separation of concerns- The first Reactor Model on jvm.

        		 Netty Application
		             |
          	         nettycore
			     |
			    nio
			     |
		            jvm

Apache MINA 

  Apache MINA is a network application framework which helps users develop high performance and high scalability network applications easily.
 It provides an abstract event-driven asynchronous API over various transports such as TCP/IP and 

UDP/IP via Java NIO.
NIO framework library,
client server framework library, or
a networking socket library

		    Apache MINA 
		         |
          	      Minaapi
			 |
			nio
			 |
		        jvm

Eclipse Vert.x is one of them.


Vertx:

Birth of Vertx Project

Vertx was born to simulate Node.js Capability on JVM.
 initally it was named "Node.X"

A core project, called vertx-core, provides the APIs for asynchronous programming, non-blocking I/O, streaming, and convenient access to networked protocols such as TCP, UDP, DNS, HTTP or Web Sockets,

Vertx is industry ready , polyglot toolkit for building Non blocking,async,evented io applications.

Vertx has been built on the top of Netty Core.

Vertx is industry ready , polyglot toolkit for building Non blocking,async,evented io applications.

Vertx has been built on the top of Netty Core.


			VertxApplication
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM

Objective of VertX:
   
    100% non blocking applications on jvm.



NonBlocking IO Apis


                     NonBlocking IO Application -VertApplication
   --------------------------------------------------------------------		
    Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM


vert-x is poly glot:

 Vertx is java technology platform, Vertx runs on JVM.
 Fundamentally JVM supports multiple language as JVM Spec dt 2003.


             Java PL  Groovy Kotlin  Javascript  scala Ruby
	            	|       |     |         |         |     |
      -------------------------------------------------------------
                               .class
				                         |
   --------------------------------------------------------------------		
       Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM
                                


				 Vertx Tech Stack


Spring is collection of projects called modules
  like core,data,mvc,integration,micro service.............

Like Spring Vertx is also collection projects

Vertx-core
vertx-web
Vertx-Data
Vertx-Reactive Extension
Vertx-Microservices
Vertx-Messaging
Vertx-Security
Vertx-Integration
Vertx-Devops Engineering
Vertx-Testing
Vertx-Clusters
Vertx-Services
Vertx-Cloud

Vertx-Core:
Writing TCP clients and servers
Writing HTTP clients and servers including support for WebSockets
The Event bus
Shared data - local maps and clustered distributed maps
Periodic and delayed actions
Deploying and undeploying Verticles
Datagram Sockets
DNS client
File system access
High availability
Native transports
Clustering   

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Lets code:

-Vertx Project setup

-Maven Project
-Gradle Project

1.plain maven project, add vertx depedencies,You can use template entry method provided by vertx .

2.Vertx Starter project

3.Vertx maven cli project

Vetx Distribution:

-maven
-zip

download zip and extract and set path 
C:\softwares\vert.x-3.9.2-full\vertx\bin

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
How to run vertx application?

We have many ways:

1.via maven.

running:
To launch your tests:

./mvnw clean test
To package your application:

./mvnw clean package
To run your application:

./mvnw clean compile exec:java



2.fat jar running:

you can pack vertx application into fat jar and you can

mvnw clean package

Running

java -jar target/vertx-apps-1.0.0-SNAPSHOT-fat.jar


3.via vertx command line.


vertx run ProgrammName.java

C:\session\ibm\Sep\vertx-apps\src\main\java\com\ibm\vertx>vertx run MainVerticle.java
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
HTTP server started on port 8888
Succeeded in deploying verticle


4.via coding - to be discussed later

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Vertx Core Concepts:

1.Vertx Instance
2.Verticle

io.vertx.core package is core package

Vertx Instance:

 It is Object,Container Object. like Spring Container.

-it is entry and exit point of vertx application.
-on jvm(single) process can have single vertx instance.
-vertx can host other objects.


To create an instance of this class you can use the static factory methods:

 vertx(), 
 vertx(io.vertx.core.VertxOptions) 
 clusteredVertx(io.vertx.core.VertxOptions, Handler).

1.how to create vertx instance

Vertx Instance can do 

Creating TCP clients and servers
Creating HTTP clients and servers
Creating DNS clients
Creating Datagram sockets
Setting and cancelling periodic and one-shot timers
Getting a reference to the event bus API
Getting a reference to the file system API
Getting a reference to the shared data API
Deploying and undeploying verticles


How to create vertx instance?

package com.ibm.vertx.core;

import io.vertx.core.Vertx;

public class CreateVertxInstanceUsingFactory {
  public static void main(String[] args) {
    //create Vertx Container object
    Vertx vertx = Vertx.vertx();
    System.out.println(vertx.toString());
  }
}

Verticle:
  -It is java object
  -It can be deployed and undeployed on vertx instance.
  -It is based on design pattern called "Actor-like Model"
  -Verticles are bound to "Event loop" , are processed by event loops.

erticle is interface which provides life cycle methods 
  -init
  -start - called when verticle during deployment
  -stop  - called when verticles during undeployment

 How to use Verticle?

 AbstractVerticle is base class for creating our own verticles.

eg:
 if you are going to implement servlet , 

public class MyServlet extends HttpServlet{

  init  
  doGet
  doPost
  destroy
}

Use case First verticle :



import io.vertx.core.AbstractVerticle;

public class HelloWorldVerticle extends AbstractVerticle {

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("HelloWorld Verticle is deployed");
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("HelloWorld Verticle is un deployed");

  }
}

if you run any verticle, we need launcher

lanucher could be main method or vertx cmd , via maven - maven needs lanucher

in case maven /fat , in side pom.xml we have to define, launcer

  <properties>
    <main.verticle>com.ibm.vertx.MainVerticle</main.verticle>
  </properties>

 <Main-Class>io.vertx.core.Launcher</Main-Class>
 <Main-Verticle>${main.verticle}</Main-Verticle>


Programmetic deployment:
.......................
package com.ibm.vertx.core;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Vertx;

public class HelloWorldVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    //vertx.deployVerticle(new HelloWorldVerticle());
    //pass class name in string format
    //vertx.deployVerticle("com.ibm.vertx.core.HelloWorldVerticle");
    vertx.deployVerticle(HelloWorldVerticle.class.getName());
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("HelloWorld Verticle is deployed");
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("HelloWorld Verticle is un deployed");
  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////

via Runner class deployement:
..............................

  public static void main(String[] args) {
    Runner.runExample(HelloWorldVerticle.class);
  }



Vertx apps:
 Collection of Verticles which can talk each other, they can exchanges messages

Vertx Application must have one single root / main verticle from where verticle application is started.



package com.ibm.vertx.verticles;

import com.ibm.vertx.core.HelloWorldVerticle;
import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;

class GreeterVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Greeter ");
  }
}

class HelloVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Hello");
  }
}

public class MainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(MainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    //access vertx instance via abstract verticle
    System.out.println("Main Verticle starts");
    vertx.deployVerticle(new GreeterVerticle());
    vertx.deployVerticle(new HelloWorldVerticle());
  }
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Vert x and Event loop:

Vertx process events comming from kernal space , via event loop, still it is while loop but that loop
bound to a thread , that thread is called event loop thread.

Every verticle by default is bound to a thread Event loop thread.

Verticle can handle events and process them.

How many event loops are there in vertx?

In node js , only one event loop.

In vertx per cpu core 2 event loops.

eg , if i have 12 cores - 24 event loop.


Event Handlers:
..............

Vertx Handlers - Event Handlers:
................................

Vertx Event Handlers can be in written in two ways

1.Future && Promise Pattern : Functional style
2.Reactive Pattern - RxJava2


if you come from java script && node.js background,you know the concept called "Callback function" - callback function is other wise called as "listener function" or "handler function".



1.Handler functions are not called by developers directly like other functions.
2.Handlers functions are called by a thread "Event Loop".
3.Handler functions are available inside Event Queue as passive instruction.
4.Once async operation(task-database connnection) is completed, os triggers event, along with event, data, and its   handler is pushed into event queue, event loop starts processing.

What is handler function/callback function/listener function for?
To handle async success /failure result.
   The result of async opertion could be either success or failure


io.vertx.Future:

-it is interface used to handle async success/failure results.

io.vertx.core

Future Interface 
				AsyncResult       Handler
				-------------------------
					   |
				     Future



Future interface is used to handle the result of async operation.


Future is interface , encapsulate response(Success/failure), we need to create Object 
for "Future" implementation
 Future f = Future.future() // create FutureImpl object

Two major api for response:


1.complete()  and complete(T result) =>Success Response, encasulated inside this api

2.fail(String failureMessage) and fail(Throwable cause) =>Failure response, encapsulate  inside this api.


Handler apis for handling response;
...................................

1.succeeded() : empty response
2.default Future<T> setHandler(Handler<AsyncResult<T>> handler)
3.default Future<T> onComplete(Handler<AsyncResult<T>> handler)
4.onSuccess
5.onFailure

AsyncResult interface apis

 -result() - get the success result sent by Future
 -cause()   -get the failure result sent by Future
 -succeed() -test whether it was success or failure
 -failed()  -test whether it was failure or success


coding use case
Future may
 -not return any value ; empty
 -may return success result
 -may return failure result
 -may return either success/failure - biz use case

steps

callee:
1.create future object using Future.future factory method
2.wrap result -  empty / success/failure
3.return the future.

caller
4.handle the future


package com.ibm.vertx.asyncwrappers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.AsyncResult;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.example.util.Runner;


class FutureVerticle extends AbstractVerticle {

  //future object creation and how to use
  public Future<Void> getEmptyFuture() {
    //how to send empty success response
    Future<Void> future = Future.future();
    //encapsulate response : success/ failure
    future.complete();
    //return future instance reference
    return future;
  }

  //future object which sends success result ; String
  public Future<String> getSuccessFuture() {
    //create Future
    Future<String> future = Future.future();

    //encapsulate success result
    future.complete("Hello , This is Vertx future");

    return future;
  }

  //future object which sends failure result ; String
  public Future<String> getFailureFuture() {
    //create Future
    Future<String> future = Future.future();

    //encapsulate success result
    future.fail("Hello ,This failed Response");

    return future;
  }

  //biz logic
  public Future<String> loginFuture() {
    //create Future
    Future<String> future = Future.future();
    //biz logic
    String userName = "admin";
    String password = "admin";
    if (userName.equals("admin") && password.equals("admin")) {
      future.complete("Login Success " + userName);
    } else {
      future.fail("Login failed");
    }

    return future;
  }


  @Override
  public void start() throws Exception {
    super.start();
    //handle async result.
    if (getEmptyFuture().succeeded()) {
      System.out.println("Result is success");
    }
    //handle success response
    getSuccessFuture().setHandler(new Handler<AsyncResult<String>>() {
      @Override
      public void handle(AsyncResult<String> event) {
        //read result
        if (event.succeeded()) {
          System.out.println(event.result());
        } else {
          System.out.println(event.cause());
        }
      }
    });
    getSuccessFuture().setHandler(event -> {
      //read result
      if (event.succeeded()) {
        System.out.println(event.result());
      } else {
        System.out.println(event.cause());
      }
    });
    getSuccessFuture().onComplete(event -> {
      //read result
      if (event.succeeded()) {
        System.out.println(event.result());
      } else {
        System.out.println(event.cause());
      }
    });
    getSuccessFuture().onSuccess(response -> System.out.println(response));
    getSuccessFuture().onSuccess(System.out::println);
    //
    getFailureFuture().onComplete(event -> {
      //read result
      if (event.succeeded()) {
        System.out.println(event.result());
      } else {
        System.out.println(event.cause());
      }
    });
    getFailureFuture().onFailure(System.out::println);
    ////////////////////////////////////////////////////////////
    loginFuture().onComplete(event -> {
      if (event.succeeded()) {
        System.out.println(event.result());
      } else {
        System.out.println(event.cause());
      }
    });
    loginFuture()
      .onSuccess(System.out::println)
      .onFailure(System.out::println);

  }
}


public class FutureMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(FutureMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new FutureVerticle());
  }
}
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Future Object creation:

1.Future future = Future.future()

2.Future.succeedFuture
  Future.FailedFuture

 public Future<String> loginFutureUsingFactory() {
    //biz logic
    String userName = "admin";
    String password = "admin";
    if (userName.equals("admin") && password.equals("admin")) {
      return Future.succeededFuture("Login Success " + userName);
    }
    return Future.failedFuture("Login failed");

  }

Async Wrapper Object : Promise:
...............................

Promise is async abstraction largly promoted by javascript community.

Dont Compare  javascript Promises with Vertx Promises , because both are different.

Promise is "semantically meaningfull abstraction" for handling asyn results.

Many times developers confuse with java Future and Vertx Future.

Promises can't be processed directly with onComplete/setHandler/OnSuccecc/onFailure apis.



package com.ibm.vertx.asyncwrappers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class PromiseVerticle extends AbstractVerticle {

  public Future<String> getSuccess() {
    Promise<String> promise = Promise.promise();
    promise.complete("Hello Promise");
    return promise.future();
  }

  public Future<String> login() {
    //create Future
    Promise<String> promise = Promise.promise();
    //biz logic
    String userName = "admin";
    String password = "admin";
    if (userName.equals("admin") && password.equals("admin")) {
      promise.complete("Login Success " + userName);
    } else {
      promise.fail("Login failed");
    }

    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    getSuccess().onSuccess(System.out::println);
    login()
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}

public class PromiseVerticleMain extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(PromiseVerticleMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new PromiseVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Legacy Application flow : object oriented and sync flow
  
dependent operations  , should happen one by one

Object oriented seq work flow

 1.connect db - connect()
 2.Query results -queryResult()
 3.Formate results -formateResult()
 4.add results into http response stream - write()
 5.send/flush the results to clients - send()

 Connection con=connect();
 QueryResult queryres=con.queryResult()
 ..................................................................

 Functional sequential workflow:

 Nested Callback : Callback chaining: functional style

  Handler function is called as callback function

"The out put of one callback is input to the another callback : nested callbacks

   cb1
     --cb2
         -cb3
            --cbN
              --process the result.


Use case :

 getUser ----|if data is available
			|	|
			|
			      	 call login method with  output of getUser
                        |
		     if not
			 -error


package com.ibm.vertx.callback.composition;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class UserVerticle extends AbstractVerticle {

  public Future<String> getUser() {
    Promise<String> promise = Promise.promise();
    //biz
    String userName = "admin";
    if (userName != null) {
      promise.complete(userName);
    } else {
      promise.fail("User not found");
    }

    return promise.future();
  }

  public Future<String> login(String userName) {
    Promise<String> promise = Promise.promise();
    //biz
    if (userName.equals("admin")) {
      promise.complete("login success");
    } else {
      promise.fail("login failed");
    }
    return promise.future();
  }

  public Future<String> page(String status) {
    Promise<String> promise = Promise.promise();
    //biz
    if (status.equals("login success")) {
      promise.complete("Admin Page");
    } else {
      promise.fail("Guest Page");
    }
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    getUser().onComplete(event -> {
      if (event.succeeded()) {
        System.out.println("getUser is called ");
        login(event.result()).onComplete(loginevent -> {
          if (loginevent.succeeded()) {
            System.out.println("login is called");
            page(loginevent.result()).onComplete(pageevent -> {
              System.out.println("Page is called");
              if (pageevent.succeeded()) {
                System.out.println(pageevent.result());
              } else {
                System.out.println(pageevent.cause());
              }
            });
          } else {
            System.out.println(loginevent.cause());
          }
        });
      } else {
        System.out.println(event.cause());
      }
    });
  }
}


public class FunctionalCompositionVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(FunctionalCompositionVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new UserVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
callback Hell:
 The way we write nested callbacks.
 doom of pyrmid


getUser().onComplete(event -> {
      if (event.succeeded()) {
        System.out.println("getUser is called ");
        login(event.result()).onComplete(loginevent -> {
          if (loginevent.succeeded()) {
            System.out.println("login is called");
            page(loginevent.result()).onComplete(pageevent -> {
              System.out.println("Page is called");
              if (pageevent.succeeded()) {
                System.out.println(pageevent.result());
              } else {
                System.out.println(pageevent.cause());
              }
            });
          } else {
            System.out.println(loginevent.cause());
          }
        });
      } else {
        System.out.println(event.cause());
      }
    });



Look at the above code , ask your self

1.is it easy to understand?
2.is it easy to scale
3.is it easy to maintain

No!



can we escape from callback hell problem, how to write better callback based programming?

Yes! 


Solution to callback Hell:
..........................
compose method of Future


package com.ibm.vertx.callback.composition;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.example.util.Runner;

class UserVerticle extends AbstractVerticle {

  public Future<String> getUser() {
    Promise<String> promise = Promise.promise();
    //biz
    String userName = "admin";
    if (userName != null) {
      promise.complete(userName);
    } else {
      promise.fail("User not found");
    }

    return promise.future();
  }

  public Future<String> login(String userName) {
    Promise<String> promise = Promise.promise();
    //biz
    if (userName.equals("admin")) {
      promise.complete("login success");
    } else {
      promise.fail("login failed");
    }
    return promise.future();
  }

  public Future<String> page(String status) {
    Promise<String> promise = Promise.promise();
    //biz
    if (status.equals("login success")) {
      promise.complete("Admin Page");
    } else {
      promise.fail("Guest Page");
    }
    return promise.future();
  }

  public void callbackHellCode() {
    getUser().onComplete(event -> {
      if (event.succeeded()) {
        System.out.println("getUser is called ");
        login(event.result()).onComplete(loginevent -> {
          if (loginevent.succeeded()) {
            System.out.println("login is called");
            page(loginevent.result()).onComplete(pageevent -> {
              System.out.println("Page is called");
              if (pageevent.succeeded()) {
                System.out.println(pageevent.result());
              } else {
                System.out.println(pageevent.cause());
              }
            });
          } else {
            System.out.println(loginevent.cause());
          }
        });
      } else {
        System.out.println(event.cause());
      }
    });
  }
  //how to avoid callback hell code

  public void compose() {

    getUser().compose(userName -> {
      System.out.println("getUser is called ");
      return login(userName);
    }).compose(status -> {
      System.out.println("login is called");
      return page(status);
    }).onSuccess(System.out::println)
      .onFailure(System.out::println);

    getUser()
      .compose(userName -> login(userName))
      .compose(status -> page(status))
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }

  @Override
  public void start() throws Exception {
    super.start();
    compose();
  }
}


public class FunctionalCompositionVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(FunctionalCompositionVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new UserVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Function as Parameter pattern; 


  //we dont want to return future/promise but we need to transfer data to caller

  public void prepareDatabase(Handler<AsyncResult<String>> aHandler) {
    String connectionString = "localhost;3302;mongodb";
    if (connectionString != null) {
      //wrap result into future
      aHandler.handle(Future.succeededFuture(connectionString));
    } else {
      aHandler.handle(Future.failedFuture("Connection is not available"));
    }
  }

   prepareDatabase(asyncResult -> {
      if (asyncResult.succeeded()) {
        System.out.println(asyncResult.result());
      } else {
        System.out.println(asyncResult.cause());
      }
    });

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Data Formates in vertx:

1.Buffer
2.JSON object
3.Message


Buffer
JSON


Buffer:

1.Verticles running in vertx often need to process blocks of data.
2.For instance , data from an incomming http request, data loaded from the disk or data generated as response to http request etc.
3.A Buffer in vertx can hold binary data.
4.Buffer is similar to byte array, except the buffer can expand its capacity dynamically  as you write data to it.

package com.ibm.vertx.dataformat;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.buffer.Buffer;
import io.vertx.example.util.Runner;

public class BufferVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BufferVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    //Buffer
    Buffer buffer = Buffer.buffer();
    buffer.appendString("Hello");
    buffer.appendString("Hai");
    buffer.appendString("Welcome");
    buffer.appendString("How are you");
    buffer.appendString("this is binary data");
    System.out.println(buffer.length());
    System.out.println(buffer.toString());
  }
}

JSON Object :Data Interchange format 

Vertx provides a Json Objects

1.JsonObject
2.JsonArray

package com.ibm.vertx.dataformat;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

public class JSONVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(JSONVerticle.class);
  }

  public void simpleJSON() {
    JsonObject message = new JsonObject();
    message.put("name", "Subramanian");
    message.put("when", 1);
    message.put("status", true);
    System.out.println(message.getString("name"));
    System.out.println(message.getInteger("when"));
    System.out.println(message.getBoolean("status"));
    //json.stringify - string representation
    System.out.println(message.encodePrettily());

  }

  //vertx apis are fluent API:A fluent API is where multiple methods calls can be chained together
  public void simpleWithFluentJSON() {
    JsonObject message = new JsonObject().put("name", "Subramanian").put("when", 1).put("status", true);
    System.out.println(message.getString("name"));
    System.out.println(message.getInteger("when"));
    System.out.println(message.getBoolean("status"));
    //json.stringify - string representation
    System.out.println(message.encodePrettily());
  }

  //nested json
  public void nestedJson() {
    JsonObject message = new JsonObject().put("name", "Subramanian")
      .put("when", 1)
      .put("status", true)
      .put("address", new JsonObject().put("city", "coimbatore")
        .put("state", "Tamil Nadue"));
    System.out.println(message.getString("name"));
    System.out.println(message.getInteger("when"));
    System.out.println(message.getBoolean("status"));
    //json.stringify - string representation
    System.out.println(message.encodePrettily());
  }

  //list of jsons [ ]
  public void listofJson() {
    JsonArray list = new JsonArray()
      .add(new JsonObject().put("name", "Subramanian")
        .put("when", 1)
        .put("status", true)
        .put("address", new JsonObject().put("city", "coimbatore")
          .put("state", "Tamil Nadue")))
      .add(new JsonObject().put("name", "Subramanian")
        .put("when", 1)
        .put("status", true)
        .put("address", new JsonObject().put("city", "coimbatore")
          .put("state", "Tamil Nadue")));

    //json.stringify - string representation
    System.out.println(list.encodePrettily());
  }

  //how to reuturn json with Future/Promise
  public Future<JsonObject> getPromise() {
    Promise<JsonObject> promise = Promise.promise();
    JsonObject message = new JsonObject().put("name", "Subramanian")
      .put("when", 1)
      .put("status", true)
      .put("address", new JsonObject().put("city", "coimbatore")
        .put("state", "Tamil Nadue"));
    promise.complete(message);
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    simpleJSON();
    simpleWithFluentJSON();
    nestedJson();
    listofJson();
    getPromise().onSuccess(res -> {
      System.out.println(res.encodePrettily());
    });
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
non blocking apis:

Creating TCP clients and servers
Creating HTTP clients and servers
Creating DNS clients
Creating Datagram sockets
Setting and cancelling periodic and one-shot timers
Getting a reference to the event bus API
Getting a reference to the file system API


Timer api
 

io api
 -fs
 -networking api


Timer api:
package com.ibm.vertx.async.timers;

import io.vertx.core.*;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

public class TimerVerticleMain extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(TimerVerticleMain.class);
  }

  //timeout
  public void timeout(long delay) {
    //create timer , fire callback function/handler function
    vertx.setTimer(delay, timerId -> {
      System.out.println("Timer ID :" + timerId);
      System.out.println("Called after " + delay);

    });
  }

  public Future<JsonObject> getDataIndelay(long delay) {
    //create timer , fire callback function/handler function
    Promise<JsonObject> promise = Promise.promise();
    vertx.setTimer(delay, timerId -> {
      //encaspulate data , will be sent to caller called after some delay
      promise.complete(new JsonObject().put("message", "Hello"));
    });
    return promise.future();
  }

  public void getDataCallback(long delay, Handler<AsyncResult<JsonObject>> aHandler) {
    vertx.setTimer(delay, timerId -> {
      aHandler.handle(Future.succeededFuture(new JsonObject().put("message", "Welcome")));
    });
  }

  //i want to fire every delay ms
  public void heartBeat(long delay, Handler<AsyncResult<Double>> aHandler) {
    long timerId = vertx.setPeriodic(delay, id -> {
      aHandler.handle(Future.succeededFuture(Math.random()));
    });
    //cancle the polling after some time-
    vertx.setTimer(10000, arid -> {
      System.out.println("stopping producing random numbers");
      vertx.cancelTimer(timerId);
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("start");
    timeout(1000);
    timeout(5000);
    getDataIndelay(2500).onComplete(event -> {
      if (event.succeeded()) {
        System.out.println(event.result().encodePrettily());
      }
    });
    getDataCallback(3000, timerHandler -> {
      if (timerHandler.succeeded()) {
        System.out.println(timerHandler.result().encodePrettily());
      }
    });
    //get data
    heartBeat(1000, ar -> {
      System.out.println(ar.result().doubleValue());
    });

    System.out.println("end");
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Vertx Microservices:
...................

Communication between objects and applications
..............................................

Communicaiton styles:

1.HTTP communication -
2.TCP  communication - RPI
3.Message communication- RabbitMQ,kaffa...


Vertx supports all types of communication.

1.Messaging communication.

 Vertx provides built in message model where verticles can communicate in loosly coupled and async  way.


In Vertx, How objects(Verticles) communicate each other?

 Via MOM like architecture, event bus

Event Bus:

-Event Bus is nerve of vertx systems.

-Vertx By default is distributed

-Vertx carries distributed architecture by default

-In Vertx Verticles can communicate via Centraized Broker which is built in called event Bus.

-Event Bus uses tcp transport layer by default
-EventBus can send and recive data in the form of json and buffer


How verticle has been designed to adopt this architecture?

Verticle follows a design pattern  "Actor-like Model" ---->Actor Model design pattern


https://doc.akka.io/docs/akka/current/typed/guide/actors-intro.html


Event Bus:

1.Event Bus can allow verticles sends data from one place to another place
2.Event Bus forms a distributed peer-to-peer messaging system spannining multiple server nodes   and multiple browers.
3.Event bus allows sending messages in three ways
  1.pub/sub : one to many
  2.point-to-point : one to one
  3.request-reply(reponse) - one to one with acknowlegement.

4.Event bus identifies clients via "addressing"
   Messages are sent on the event bus to an "address"
   Address schemes can be any naming convention, recommendation is dns model "in.news.covid"
   
5.Handlers
   Since vertx is non blocking, messages are processed by handlers.
   You have to register a handler at an address

6.Type of Data
   Data type of message could be any primitive-int,char,boolean,String, Buffer,JSON

   Per Vertx Engine only One Event Bus-singleTon


PUB-SUB:
package com.ibm.vertx.microservices.eventbus;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;

class Address {
  public static String PUBSUBADDRESS = "news.in.covid";
}

//pub-sub one to many
class NewsSevenVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUBSUBADDRESS);
    messageConsumer.handler(news -> {
      System.out.println(this.getClass().getName() + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class BBCVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUBSUBADDRESS);
    messageConsumer.handler(news -> {
      System.out.println(this.getClass().getName() + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class NDTVVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUBSUBADDRESS);
    messageConsumer.handler(news -> {
      System.out.println(this.getClass().getName() + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

//publisher publish news to all news tv channels
class PublisherVerticle extends AbstractVerticle {

  public void publish() {
    //Get EventBus Object reference
    EventBus eventBus = vertx.eventBus();
    //publish a message : pub-sub
    String message = "Last 24 Hrs covid count is 80000";
    vertx.setTimer(1000, ar -> {
      eventBus.publish(Address.PUBSUBADDRESS, message);
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    publish();
  }
}

public class EventBusMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusMainVerticle.class);
  }

  public void pubsub() {
    vertx.deployVerticle(new PublisherVerticle(), handler -> {
      if (handler.succeeded()) {
        //each verticle is assigned with unique deployment id;
        System.out.println("PublisherVerticle " + handler.result() + " Successfully deployed");
      }
    });
    vertx.deployVerticle(new BBCVerticle(), handler -> {
      if (handler.succeeded()) {
        //each verticle is assigned with unique deployment id;
        System.out.println("BBCVerticle " + handler.result() + " Successfully deployed");
      }
    });
    vertx.deployVerticle(new NewsSevenVerticle(), handler -> {
      if (handler.succeeded()) {
        //each verticle is assigned with unique deployment id;
        System.out.println("NewsSevenVerticle " + handler.result() + " Successfully deployed");
      }
    });
    vertx.deployVerticle(new NDTVVerticle(), handler -> {
      if (handler.succeeded()) {
        //each verticle is assigned with unique deployment id;
        System.out.println("NDTVVerticle " + handler.result() + " Successfully deployed");
      }
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    pubsub();

  }
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Point to Point
package com.ibm.vertx.microservices.eventbus;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;

class Address {
  public static String PUBSUBADDRESS = "news.in.covid";
  public static String POINTOPOINT = "fund.in.covid.request";
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//point to point
class CenertalFinanceVerticle extends AbstractVerticle {

  public void consume() {
    EventBus eventBus = vertx.eventBus();
    //pub-sub
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.POINTOPOINT);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request -  : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

//point to point publisher
class FinanceRequestVerticle extends AbstractVerticle {

  public void requestFinance() {
    //
    System.out.println("Finance Request started....");
    vertx.setTimer(5000, ar -> {
      //point to point : send method
      String message = "Dear Team, We request that we want 1 Billion Money for Covid";
      //point to p
      vertx.eventBus().send(Address.POINTOPOINT, message);
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    requestFinance();
  }
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////
//pub-sub one to many
class NewsSevenVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUBSUBADDRESS);
    messageConsumer.handler(news -> {
      System.out.println(this.getClass().getName() + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class BBCVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUBSUBADDRESS);
    messageConsumer.handler(news -> {
      System.out.println(this.getClass().getName() + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class NDTVVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUBSUBADDRESS);
    messageConsumer.handler(news -> {
      System.out.println(this.getClass().getName() + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

//publisher publish news to all news tv channels
class PublisherVerticle extends AbstractVerticle {

  public void publish() {
    //Get EventBus Object reference
    EventBus eventBus = vertx.eventBus();
    //publish a message : pub-sub
    String message = "Last 24 Hrs covid count is 80000";
    vertx.setTimer(1000, ar -> {
      eventBus.publish(Address.PUBSUBADDRESS, message);
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    publish();
  }
}

public class EventBusMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusMainVerticle.class);
  }

  public void pubsub() {
    vertx.deployVerticle(new PublisherVerticle(), handler -> {
      if (handler.succeeded()) {
        //each verticle is assigned with unique deployment id;
        System.out.println("PublisherVerticle " + handler.result() + " Successfully deployed");
      }
    });
    vertx.deployVerticle(new BBCVerticle(), handler -> {
      if (handler.succeeded()) {
        //each verticle is assigned with unique deployment id;
        System.out.println("BBCVerticle " + handler.result() + " Successfully deployed");
      }
    });
    vertx.deployVerticle(new NewsSevenVerticle(), handler -> {
      if (handler.succeeded()) {
        //each verticle is assigned with unique deployment id;
        System.out.println("NewsSevenVerticle " + handler.result() + " Successfully deployed");
      }
    });
    vertx.deployVerticle(new NDTVVerticle(), handler -> {
      if (handler.succeeded()) {
        //each verticle is assigned with unique deployment id;
        System.out.println("NDTVVerticle " + handler.result() + " Successfully deployed");
      }
    });

  }

  public void pointToPoint() {
    vertx.deployVerticle(new CenertalFinanceVerticle(), handler -> {
      if (handler.succeeded()) {
        //each verticle is assigned with unique deployment id;
        System.out.println("CenertalFinanceVerticle " + handler.result() + " Successfully deployed");
      }
    });
    vertx.deployVerticle(new FinanceRequestVerticle(), handler -> {
      if (handler.succeeded()) {
        //each verticle is assigned with unique deployment id;
        System.out.println("FinanceRequestVerticle " + handler.result() + " Successfully deployed");
      }
    });
  }


  @Override
  public void start() throws Exception {
    super.start();
    //pubsub();
    pointToPoint();
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Request-Reply with Ack:.
......................

package com.ibm.vertx.microservices.eventbus;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.example.util.Runner;

class Address {
  public static String PUBSUBADDRESS = "news.in.covid";
  public static String POINTOPOINT = "fund.in.covid.request";
  public static String REQUESTREPLY = "report.in.covid";
}
////////////////////////////////////////////////////////////////////////////////////////////////////////
//request-reply

class LabVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    //pub-sub
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.REQUESTREPLY);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request -  : " + news.body());
      //sending reply /ack
      news.reply("Patient is Crictal, Need More attention");
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class ReportVerticle extends AbstractVerticle {

  public void sendReport() {
    vertx.setTimer(5000, ar -> {
      String message = "Report of Mr.x";

      vertx.eventBus().request(Address.REQUESTREPLY, message, asyncResult -> {
        if (asyncResult.succeeded()) {
          System.out.println(asyncResult.result().body());
        } else {
          System.out.println(asyncResult.cause());
        }
      });
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    sendReport();
  }
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////
//point to point
class CenertalFinanceVerticle extends AbstractVerticle {

  public void consume() {
    EventBus eventBus = vertx.eventBus();
    //pub-sub
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.POINTOPOINT);
    //handle /process the message/news
    messageConsumer.handler(news -> {
      System.out.println("Request -  : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

//point to point publisher
class FinanceRequestVerticle extends AbstractVerticle {

  public void requestFinance() {
    //
    System.out.println("Finance Request started....");
    vertx.setTimer(5000, ar -> {
      //point to point : send method
      String message = "Dear Team, We request that we want 1 Billion Money for Covid";
      //point to p
      vertx.eventBus().send(Address.POINTOPOINT, message);
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    requestFinance();
  }
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////
//pub-sub one to many
class NewsSevenVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUBSUBADDRESS);
    messageConsumer.handler(news -> {
      System.out.println(this.getClass().getName() + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class BBCVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUBSUBADDRESS);
    messageConsumer.handler(news -> {
      System.out.println(this.getClass().getName() + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

class NDTVVerticle extends AbstractVerticle {
  public void consume() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer(Address.PUBSUBADDRESS);
    messageConsumer.handler(news -> {
      System.out.println(this.getClass().getName() + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consume();
  }
}

//publisher publish news to all news tv channels
class PublisherVerticle extends AbstractVerticle {

  public void publish() {
    //Get EventBus Object reference
    EventBus eventBus = vertx.eventBus();
    //publish a message : pub-sub
    String message = "Last 24 Hrs covid count is 80000";
    vertx.setTimer(1000, ar -> {
      eventBus.publish(Address.PUBSUBADDRESS, message);
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    publish();
  }
}

public class EventBusMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(EventBusMainVerticle.class);
  }

  public void pubsub() {
    vertx.deployVerticle(new PublisherVerticle(), handler -> {
      if (handler.succeeded()) {
        //each verticle is assigned with unique deployment id;
        System.out.println("PublisherVerticle " + handler.result() + " Successfully deployed");
      }
    });
    vertx.deployVerticle(new BBCVerticle(), handler -> {
      if (handler.succeeded()) {
        //each verticle is assigned with unique deployment id;
        System.out.println("BBCVerticle " + handler.result() + " Successfully deployed");
      }
    });
    vertx.deployVerticle(new NewsSevenVerticle(), handler -> {
      if (handler.succeeded()) {
        //each verticle is assigned with unique deployment id;
        System.out.println("NewsSevenVerticle " + handler.result() + " Successfully deployed");
      }
    });
    vertx.deployVerticle(new NDTVVerticle(), handler -> {
      if (handler.succeeded()) {
        //each verticle is assigned with unique deployment id;
        System.out.println("NDTVVerticle " + handler.result() + " Successfully deployed");
      }
    });

  }

  public void pointToPoint() {
    vertx.deployVerticle(new CenertalFinanceVerticle(), handler -> {
      if (handler.succeeded()) {
        //each verticle is assigned with unique deployment id;
        System.out.println("CenertalFinanceVerticle " + handler.result() + " Successfully deployed");
      }
    });
    vertx.deployVerticle(new FinanceRequestVerticle(), handler -> {
      if (handler.succeeded()) {
        //each verticle is assigned with unique deployment id;
        System.out.println("FinanceRequestVerticle " + handler.result() + " Successfully deployed");
      }
    });
  }

  public void requestReply() {
    vertx.deployVerticle(new LabVerticle(), handler -> {
      if (handler.succeeded()) {
        //each verticle is assigned with unique deployment id;
        System.out.println("LabVerticle " + handler.result() + " Successfully deployed");
      }
    });
    vertx.deployVerticle(new ReportVerticle(), handler -> {
      if (handler.succeeded()) {
        //each verticle is assigned with unique deployment id;
        System.out.println("ReportVerticle " + handler.result() + " Successfully deployed");
      }
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    //pubsub();
    // pointToPoint();
    requestReply();
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

non blocking HTTP Servers and Clients:
......................................

How to build non blocking web application

vertx offers low level api called
 vertx.createHttpServer()

Objects:

1.HttpServer
2.HttpServerRequest
3.HttpServerResponse

All these objects are created already by vertx and only we use references.


package com.ibm.vertx.microservices.http.server;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.example.util.Runner;

public class HTTPServerMainVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(HTTPServerMainVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    //create server
    HttpServer httpServer = vertx.createHttpServer();

    //start handling request-response in non blocking
    httpServer.requestHandler(request -> {
      HttpServerResponse response = request.response();
      //start sending response
      // response.write("Hello");
      //close the stream
      response.end("Hello");
    });
    //start the server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Server is up " + handler.result().actualPort());
      } else {
        System.out.println("Server is down!!!" + handler.cause());
      }
    });

  }
}

package com.ibm.vertx.microservices.http.server;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;

class SomeServiceVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> messageConsumer = eventBus.consumer("ibm.today.message");
    System.out.println("message");
    messageConsumer.handler(news -> {
      System.out.println("Message From HTTP " + news.body());
    });
  }
}

public class HTTPServerMainVerticle extends AbstractVerticle {
  String data = "";

  public static void main(String[] args) {
    Runner.runExample(HTTPServerMainVerticle.class);
  }

  //send simple message
  public void createBasicHttpServer() {
    //create server
    HttpServer httpServer = vertx.createHttpServer();

    //start handling request-response in non blocking
    httpServer.requestHandler(request -> {
      HttpServerResponse response = request.response();
      //start sending response
      // response.write("Hello");
      //close the stream
      response.end("Hello");
    });
    //start the server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Server is up " + handler.result().actualPort());
      } else {
        System.out.println("Server is down!!!" + handler.cause());
      }
    });
  }

  //sending some json data
  public void sendJson() {
    //create server
    HttpServer httpServer = vertx.createHttpServer();
    //start handling request-response in non blocking
    httpServer.requestHandler(request -> {
      HttpServerResponse response = request.response();
      response.putHeader("content-type", "application/json");
      JsonObject message = new JsonObject()
        .put("name", "Subramanian")
        .put("message", "welcome");
      response.end(message.encodePrettily());
    });
    //start the server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Server is up " + handler.result().actualPort());
      } else {
        System.out.println("Server is down!!!" + handler.cause());
      }
    });
  }

  public void readClientData() {
    //create server
    HttpServer httpServer = vertx.createHttpServer();

    //start handling request-response in non blocking
    httpServer.requestHandler(request -> {
      HttpServerResponse response = request.response();
      //read client data;
      request.bodyHandler(buffer -> {
        System.out.println(buffer.toString());

        response.end(buffer.toString());
      });
      response.endHandler(event -> {
        System.out.println("response committed");
      });

      //  response.end("Hello");
    });
    //start the server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Server is up " + handler.result().actualPort());
      } else {
        System.out.println("Server is down!!!" + handler.cause());
      }
    });
  }

  //send data to event bus ; http-event bus
  public void sendRequestDataToEventBus() {
    //create server
    HttpServer httpServer = vertx.createHttpServer();

    //start handling request-response in non blocking
    httpServer.requestHandler(request -> {
      HttpServerResponse response = request.response();
      //read client data;
      request.bodyHandler(buffer -> {
        System.out.println(buffer.toString());
        //send user data to other verticle via event bus
        data = buffer.toString();
        response.end(buffer.toString());
      });
      response.endHandler(event -> {
        vertx.eventBus().send("ibm.news.message", data.toString());

        System.out.println("response committed");
      });

      //  response.end("Hello");
    });
    //start the server
    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Server is up " + handler.result().actualPort());
      } else {
        System.out.println("Server is down!!!" + handler.cause());
      }
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new SomeServiceVerticle());
    // createBasicHttpServer();
    //sendJson();
    // readClientData();
    sendRequestDataToEventBus();

  }
}
******************************************************************************************************

can you build REST End points or dynamic content generation application?
........................................................................

Drawbacks of core http server request processing

- you cant write request method and url mapping.


web module:
..........
Objects
Router
  - used to create routes
Route
  -Each route has handler, handler has been attached with RoutingContext

RoutingContext
  -similar to servletContext



package com.ibm.vertx.microservices.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;

class MessageController {
  public static void hello(RoutingContext routingContext) {
    //two objects you can get from RoutingContext - reqest, response
    HttpServerResponse response = routingContext.response();
    response.end("Hello Message");
  }
}

public class SimpleWebVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(SimpleWebVerticle.class);
  }

  public void buildRouter() {

    HttpServer httpServer = vertx.createHttpServer();
    Router router = Router.router(vertx);
    //HTTP GET request
    router.get("/").handler(routingCtx -> {
      //two objects you can get from RoutingContext - reqest, response
      HttpServerResponse response = routingCtx.response();
      response.end("Home Page");
    });
    router.get("/api/message/hello").handler(MessageController::hello);
    router.get("/api/message/hai").handler(routingCtx -> {
      //two objects you can get from RoutingContext - reqest, response
      HttpServerResponse response = routingCtx.response();
      response.end("Hai Message");
    });
    //bind router with request
    httpServer.requestHandler(router);

    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Server is up " + handler.result().actualPort());
      } else {
        System.out.println("Server is down!!!" + handler.cause());
      }
    });
  }

  private void homePage(RoutingContext routingCtx) {
    //two objects you can get from RoutingContext - reqest, response
    HttpServerResponse response = routingCtx.response();
    response.end("Home Page");
  }

  public void buildDomainRouters() {
    HttpServer httpServer = vertx.createHttpServer();

    Router homeRouter = Router.router(vertx);
    //HTTP GET request
    homeRouter.get("/").handler(this::homePage);
    ///
    Router messageRouter = Router.router(vertx);
    //message domain
    messageRouter.get("/hello").handler(MessageController::hello);
    messageRouter.get("/hai").handler(routingCtx -> {
      //two objects you can get from RoutingContext - reqest, response
      HttpServerResponse response = routingCtx.response();
      response.end("Hai Message");
    });
    //news domain
    Router newsRouter = Router.router(vertx);
    newsRouter.get("/weather").handler(routingCtx -> {
      //two objects you can get from RoutingContext - reqest, response
      HttpServerResponse response = routingCtx.response();
      response.end("Weather News");
    });
    newsRouter.get("/sports").handler(routingCtx -> {
      //two objects you can get from RoutingContext - reqest, response
      HttpServerResponse response = routingCtx.response();
      response.end("Sports news");
    });

    //proxy router, receives requests, according to url mapping , req will redirected
    Router proxyRouter = Router.router(vertx);

    proxyRouter.mountSubRouter("/", homeRouter);
    proxyRouter.mountSubRouter("/api/message", messageRouter);
    proxyRouter.mountSubRouter("/api/news", newsRouter);

    //bind router with request
    httpServer.requestHandler(proxyRouter);

    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Server is up " + handler.result().actualPort());
      } else {
        System.out.println("Server is down!!!" + handler.cause());
      }
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    // buildRouter();
    buildDomainRouters();
  }
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Verticle to Verticle communication via WebClient:
..................................................

<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-web-client</artifactId>
 <version>3.9.2</version>
</dependency>

package com.ibm.vertx.microservices.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.example.util.Runner;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.client.HttpResponse;
import io.vertx.ext.web.client.WebClient;

class ClientVerticle extends AbstractVerticle {
  //create webclient to call server verticle

  public void callServer() {
    HttpServer httpServer = vertx.createHttpServer();

    httpServer.requestHandler(handler -> {
      String url = "/api/message/hello";
      String host = "localhost";
      WebClient webClient = WebClient.create(vertx);
      Integer port = 3000;
      webClient.get(port, host, url).send(ar -> {
        if (ar.succeeded()) {
          //Obtain Response
          HttpResponse<Buffer> response = ar.result();
          System.out.println(response.bodyAsString());
          handler.response().end(response.bodyAsString());
        } else {
          System.out.println(ar.cause());
        }
      });

    });

    httpServer.listen(3001, handler -> {
      if (handler.succeeded()) {
        System.out.println("Server is up " + handler.result().actualPort());
      } else {
        System.out.println("Server is down!!!" + handler.cause());
      }
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    callServer();
  }
}

class ServerVerticle extends AbstractVerticle {

  public void process() {

    HttpServer httpServer = vertx.createHttpServer();
    Router router = Router.router(vertx);
    //HTTP GET request
    router.get("/").handler(routingCtx -> {
      //two objects you can get from RoutingContext - reqest, response
      HttpServerResponse response = routingCtx.response();
      response.end("Home Page");
    });
    router.get("/api/message/hello").handler(MessageController::hello);
    router.get("/api/message/hai").handler(routingCtx -> {
      //two objects you can get from RoutingContext - reqest, response
      HttpServerResponse response = routingCtx.response();
      response.end("Hai Message");
    });
    //bind router with request
    httpServer.requestHandler(router);

    httpServer.listen(3000, handler -> {
      if (handler.succeeded()) {
        System.out.println("Server is up " + handler.result().actualPort());
      } else {
        System.out.println("Server is down!!!" + handler.cause());
      }
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    process();
  }
}

public class WebClientVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(WebClientVerticle.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new ServerVerticle());
    vertx.deployVerticle(new ClientVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

CURD Operation with UI:
......................

Web Templates
Data - Database - MongoDB



Template engines vertx supports

Handlebars
Jade,
MVEL
Thymeleaf
Apache FreeMarker
Pebble
Rocker


<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-mongo-client</artifactId>
 <version>3.9.2</version>
</dependency>
   <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-web-templ-jade</artifactId>
      <classifier>shaded</classifier>
      <version>3.9.2</version>
    </dependency>


Mongo db connection:
...................
JsonObject config=new JsonObject().put("db_name","demo");

MongoClient client = MongoClient.createShared(vertx, config);


save document:

JsonObject document = new JsonObject()
  .put("title", "The Hobbit");

mongoClient.save("books", document, res -> {
  if (res.succeeded()) {
    String id = res.result();
    System.out.println("Saved book with id " + id);
  } else {
    res.cause().printStackTrace();
  }
});

package com.ibm.vertx.microservices.web.data;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpHeaders;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.mongo.MongoClient;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.BodyHandler;
import io.vertx.ext.web.handler.StaticHandler;
import io.vertx.ext.web.templ.jade.JadeTemplateEngine;

class UserVerticle extends AbstractVerticle {

  public void startApplication() {
    //mongo connection
    JsonObject dbConfig = new JsonObject().put("db_name", "demo");
    MongoClient mongo = MongoClient.createShared(vertx, dbConfig);
    // In order to use a JADE template we first need to create an engine
    final JadeTemplateEngine jade = JadeTemplateEngine.create(vertx);
    final Router router = Router.router(vertx);
    // Enable the body parser to we can get the form data and json documents in out context.
    router.route().handler(BodyHandler.create());

    // Entry point to the application, this will render a custom JADE template.
    router.get("/").handler(ctx -> {
      // we define a hardcoded title for our application
      JsonObject data = new JsonObject()
        .put("title", " IBM Vert.x Web");

      // and now delegate to the engine to render it.
      jade.render(data, "templates/index.jade", res -> {
        if (res.succeeded()) {
          ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, "text/html").end(res.result());
        } else {
          ctx.fail(res.cause());
        }
      });
    });

    //interact with mongo db
    //send data
    // Create a new document on mongo.
    router.post("/users").handler(ctx -> {
      // since jquery is sending data in multipart-form format to avoid preflight calls, we need to convert it to JSON.
      JsonObject user = new JsonObject()
        .put("username", ctx.request().getFormAttribute("username"))
        .put("email", ctx.request().getFormAttribute("email"))
        .put("fullname", ctx.request().getFormAttribute("fullname"))
        .put("location", ctx.request().getFormAttribute("location"))
        .put("age", ctx.request().getFormAttribute("age"))
        .put("gender", ctx.request().getFormAttribute("gender"));

      // insert into mongo
      mongo.insert("users", user, lookup -> {
        // error handling
        if (lookup.failed()) {
          ctx.fail(lookup.cause());
          return;
        }

        // inform that the document was created
        ctx.response().setStatusCode(201);
        ctx.response().end();
      });
    });

    // Read all users from the mongo collection.
    router.get("/users").handler(ctx -> {
      mongo.find("users", new JsonObject(), lookup -> {
        if (lookup.failed()) {
          ctx.fail(lookup.cause());
          return;
        } else {
          //now convert the list to a JsonArray because it will be easier to encode the final object as the response.
          JsonArray jsonArray = new JsonArray();
          for (JsonObject ob : lookup.result()) {
            jsonArray.add(ob);
          }
          // since we are producing json we should inform the browser of the correct content type.
          ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, "application/json");
          // encode to json string
          ctx.response().end(jsonArray.encode());
        }
      });

    });

    // Remove a document from mongo.
    router.delete("/users/:id").handler(ctx -> {
      // catch the id to remove from the url /users/:id and transform it to a mongo query.
      mongo.removeOne("users", new JsonObject().put("_id", ctx.request().getParam("id")), lookup -> {
        // error handling
        if (lookup.failed()) {
          ctx.fail(lookup.cause());
          return;
        }

        // inform the browser that there is nothing to return.
        ctx.response().setStatusCode(204);
        ctx.response().end();
      });
    });
    // Serve the non private static pages
    router.route().handler(StaticHandler.create());

    // start a HTTP web server on port 8080
    vertx.createHttpServer().requestHandler(router).listen(8080);
  }

  @Override
  public void start() throws Exception {
    super.start();
    startApplication();
  }
}


public class CURDVerticleMain extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(CURDVerticleMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new UserVerticle());
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Non blocking JDBC :

    <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-jdbc-client</artifactId>
      <version>3.9.1</version>
    </dependency>
    <dependency>
      <groupId>org.hsqldb</groupId>
      <artifactId>hsqldb</artifactId>
      <version>2.3.4</version>
    </dependency>

Steps:
Connection
  // Create a JDBC client with a test database
    client = JDBCClient.createShared(vertx, new JsonObject()
      .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
      .put("driver_class", "org.hsqldb.jdbcDriver"));

Query Processing
getConnection(handler)
execute
query

create table,add mock data, query the initalie data
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

JDBC
RouterContext attributes
Router interceptors

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


package com.ibm.vertx.microservices.web.data;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Handler;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.example.util.Runner;
import io.vertx.ext.jdbc.JDBCClient;
import io.vertx.ext.sql.SQLConnection;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;

public class JDBCVerticle extends AbstractVerticle {
  private static String CREATE_TABLE = "CREATE TABLE IF NOT EXISTS products(id INT IDENTITY, name VARCHAR(255), price FLOAT, weight INT)";
  private static String INITAL_TABLE_DATA = "INSERT INTO products (name, price, weight) VALUES ('Egg Whisk', 3.99, 150), ('Tea Cosy', 5.99, 100), ('Spatula', 1.00, 80)";
  private static String GET_ALL_PRODUCTS = "SELECT id, name, price, weight FROM products";
  private JDBCClient client;


  private void sendError(int statusCode, HttpServerResponse response) {
    response.setStatusCode(statusCode).end();
  }
  public static void main(String[] args) {
    Runner.runExample(JDBCVerticle.class);
  }

  private void handleListProducts(RoutingContext routingContext) {
    HttpServerResponse response = routingContext.response();
    SQLConnection conn = routingContext.get("conn");
    conn.query(GET_ALL_PRODUCTS, query -> {
      if (query.failed()) {
        sendError(500, response);
      } else {
        JsonArray arr = new JsonArray();
        query.result().getRows().forEach(arr::add);
        routingContext.response().putHeader("content-type", "application/json").end(arr.encode());
      }
    });
  }
  public void startApplication() {
    JsonObject jdbcConfig = new JsonObject()
      .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
      .put("driver_class", "org.hsqldb.jdbcDriver");

    //connect database
    client = JDBCClient.createShared(vertx, jdbcConfig);

    //setup inital data- create table,insert sample rows
    setUpInitialData(ready -> {
      Router router = Router.router(vertx);

      router.route().handler(BodyHandler.create());

      // in order to minimize the nesting of call backs we can put the JDBC connection on the context for all routes
      // that match /products
      // this should really be encapsulated in a reusable JDBC handler that uses can just add to their app
      router.route("/products*").handler(routingContext ->
        client.getConnection(res -> {
          if (res.failed()) {
            routingContext.fail(res.cause());
          } else {
            SQLConnection conn = res.result();
            // save the connection on the context
            routingContext.put("conn", conn);
            // we need to return the connection back to the jdbc pool. In order to do that we need to close it, to keep
            // the remaining code readable one can add a headers end handler to close the connection.
            routingContext.addHeadersEndHandler(done -> conn.close(v -> {
              System.out.println(v.succeeded() ? "Connection Closed" : "Connection not closed");
            }));
            routingContext.next();
          }
        })).failureHandler(routingContext -> {
        SQLConnection conn = routingContext.get("conn");
        if (conn != null) {
          conn.close(v -> {
            System.out.println(v.succeeded() ? "Connection Closed" : "Connection not closed");
          });
        }
      });

      // router.get("/products/:productID").handler(that::handleGetProduct);
      //router.post("/products").handler(that::handleAddProduct);
      router.get("/products").handler(this::handleListProducts);

      vertx.createHttpServer().requestHandler(router).listen(8080);

    });

  }

  private void setUpInitialData(Handler<Void> done) {
    client.getConnection(res -> {
      if (res.failed()) {
        throw new RuntimeException(res.cause());
      }

      final SQLConnection conn = res.result();

      //execute to create table
      conn.execute(CREATE_TABLE, ddl -> {
        if (ddl.failed()) {
          throw new RuntimeException(ddl.cause());
        }

        //insert inital rows
        conn.execute(INITAL_TABLE_DATA, fixtures -> {
          if (fixtures.failed()) {
            throw new RuntimeException(fixtures.cause());
          }
          done.handle(null);
        });
      });
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    startApplication();
  }
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Non blocking file system api:
.............................

How to read disk file in vertx in nonblocking way.

package com.ibm.vertx.async.fs;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.file.FileSystem;
import io.vertx.example.util.Runner;

public class FileSystemVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    Runner.runExample(FileSystemVerticle.class);
  }

  public void readFile() {
    FileSystem fileSystem = vertx.fileSystem();
    //read file in non blocking way
    fileSystem.readFile("assets/info.txt", fileHandler -> {
      if (fileHandler.succeeded()) {
        System.out.println(fileHandler.result().toString());
      } else {
        System.out.println(fileHandler.cause());
      }
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("start");
    readFile();
    System.out.println("end");
  }
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Golden Rule : Dont block event loop:
.....................................

There is no gurantee that vertx can offer 100% non blocking, what if i want to write blocking opertions inside vertx.

-Non blocking operations are handled by "Event Loop" Thread.
-Blocking operations should be off loaded outside event loop thread, grab result carefully without  blocking event loop.

does vertx supports blocking code? is blocking is neccessary?How do we write blocking code? 

Yes! vertx supports blocking code.

Yes!, you cant write 100% non blocking code
.
Use case : 

You are building vertx application, vertx application need to talk to hibernate/jpa layer.
Vertx is non blocking but hibernate blocking.

if you write blocking inside non blocking vertx will throw error, but how to bridge blocking with non-blocking.

Blocking code

-Thread.sleep
-long running task
-legacy file io
-legacy network 
-database 
-external api 
.....

Event loop thread can wait for 2000ms - default wait duration : event loop thread in vertx cant 
wait / be blocked for 2000ms.

package com.ibm.vertx.blocking;

import io.vertx.core.AbstractVerticle;
import io.vertx.example.util.Runner;


class MyVerticle extends AbstractVerticle {
  public void blockMe() {
    try {
      Thread.sleep(10000);
    } catch (InterruptedException exception) {
      System.out.println(exception);
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    //write blocking code
    blockMe();
    System.out.println(Thread.currentThread().getName());
  }
}


public class BlockingVerticleMain extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BlockingVerticleMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(new MyVerticle());
  }
}


if you run the above code , vertx will throw the following messageSep 10, 2020 5:02:07 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-1,5,main]=Thread[vert.x-eventloop-thread-1,5,main] has been blocked for 2031 ms, time limit is 2000 ms
Sep 10, 2020 5:02:08 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-1,5,main]=Thread[vert.x-eventloop-thread-1,5,main] has been blocked for 3031 ms, time limit is 2000 ms
Sep 10, 2020 5:02:09 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-1,5,main]=Thread[vert.x-eventloop-thread-1,5,main] has been blocked for 4031 ms, time limit is 2000 ms
Sep 10, 2020 5:02:10 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-1,5,main]=Thread[vert.x-eventloop-thread-1,5,main] has been blocked for 5031 ms, time limit is 2000 ms
io.vertx.core.VertxException: Thread blocked
	at java.lang.Thread.sleep(Native Method)
	at com.ibm.vertx.blocking.MyVerticle.blockMe(BlockingVerticleMain.java:10)
	at com.ibm.vertx.blocking.MyVerticle.start(BlockingVerticleMain.java:20)
	at io.vertx.core.AbstractVerticle.start(AbstractVerticle.java:108)
	at io.vertx.core.Verticle.start(Verticle.java:66)
	at io.vertx.core.impl.DeploymentManager.lambda$doDeploy$9(DeploymentManager.java:556)
	at io.vertx.core.impl.DeploymentManager$$Lambda$11/764577347.handle(Unknown Source)
	at io.vertx.core.impl.ContextImpl.executeTask(ContextImpl.java:366)
	at io.vertx.core.impl.EventLoopContext.lambda$executeAsync$0(EventLoopContext.java:38)
	at io.vertx.core.impl.EventLoopContext$$Lambda$12/1690287238.run(Unknown Source)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Blocking code :

1.Through verticle itself

   The verticle itself can be isloated from the event loop.

2.Through vertx has apis executeBlocking.

Verticle Types:
  There are two types of verticles

1.Standard Verticle

2.Worker Verticle


1.Standard Verticle :
   These types of verticles are the most common and usefull type - They are always executed using an event loop thread.


2.Worker Verticle
    These run using a thread from the "Worker Pool".
    An instance is never executed concurrently by more than one thread.

Before deploying verticle, you can tell that this verticle is "Worker" / "standard".

How to isloate the whole Verticle Processing by Worker Pool thread?

 -Maker Worker Verticle

How to create Worker Verticle?

Every Object in Vertx has its own configuration?

vertx - VertxOptions
Verticle -DeploymentOptions
...

package com.ibm.vertx.blocking;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.example.util.Runner;

class MyVerticle extends AbstractVerticle {
  public void blockMe() {
    try {
      System.out.println("zzzzzz");
      Thread.sleep(5000);
      System.out.println("After sleep");
    } catch (InterruptedException exception) {
      System.out.println(exception);
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    //write blocking code
    blockMe();
    System.out.println(Thread.currentThread().getName());
  }
}


public class BlockingVerticleMain extends AbstractVerticle {
  public static void main(String[] args) {
    Runner.runExample(BlockingVerticleMain.class);
  }

  @Override
  public void start() throws Exception {
    super.start();
  //  DeploymentOptions deploymentOptions = new DeploymentOptions().setWorker(true);
    //vertx.deployVerticle(new MyVerticle(),deploymentOptions);
    vertx.deployVerticle(new MyVerticle(), new DeploymentOptions().setWorker(true));
  }
}


















































